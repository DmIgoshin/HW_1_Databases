# Домашнее задание 1. Системы хранения и обработки данных


## Цель

Выполнить домашнее задание, а также предоставить пошаговую инструкцию по нормализации таблиц и загрузке данных в DBeaver 

## Примечания

Работу вополнил: Игошин Дмитрий Владимирович.

Все картинки и скрипты находятся прямо тут. Однако для соблюдения формальных требований (и на случай сбоев) я еще создал отдельный файлик images.pdf в папке image, где собраны картинки

## Задание

Рассмотрим таблицу transaction и определим в какой нормальной форме она находится форме (0NF, 1NF, 2NF, 3NF или какой-либо другой).

Доказывать то что таблицы находятся в той или иной форме будем, начиная с предположения, будто она находится в 0NF - совсем не нормализованная.

Критерии для нахождения таблицы в 1NF:
* Отсутствие дублей (видно из скриншотов)
* В каждой ячейке находятся атомарные значения (видно из таблицы)
* В столбцах данные одного типа (видно из таблицы)
* Отсутствуют массивы и списки (тоже видно)


 ![ КАРТИНКА ГДЕ ВИДНО ОТСУТСТВИЕ ДУБЛЕЙ 1](/image/no_doubs1.png " КАРТИНКА ГДЕ ВИДНО ОТСУТСТВИЕ ДУБЛЕЙ 1")

 ![ КАРТИНКА ГДЕ ВИДНО ОТСУТСТВИЕ ДУБЛЕЙ 2](/image/no_doubs2.png " КАРТИНКА ГДЕ ВИДНО ОТСУТСТВИЕ ДУБЛЕЙ 2")

 
Отлично, обе таблицы подходят под эти критерии

Для нахождения таблицы в 2NF:
* Таблица должна находится в 1NF (доказали на предыдущем шаге)
* Таблица должна иметь ключ (в таблице transaction это transaction_id, в таблице customer - customer_id)
* Неключевые столбцы должны зависеть от ключа (на самом деле, зависимость должна быть от полного ключа, но он у нас не является составным)

Отлично, по этим критериям тоже подходит

Критерии для нахождения таблицы в 3NF:
* Таблица должна находиться в 2NF (доказали на предыдущем шаге)
* Должна отсутствовать транзитивная зависимость между неключевыми столбцами (то есть в первой таблице столбцы должны зависеть только от transaction_id, но не друг от друга. Во второй таблице - столбцы должны зависеть только от customer_id)

 Я составил сравнительную таблицу (для transaction), в которой проверил наличие зависимостей между (brand, product line, product_class, product_size) как составным ключом и столбцами list_price и standard_cost. Зависимость не подтвердилась. На первый взгляд может показаться, что все 4 параметра, которые я взял в скобки, однозначно задают цену - оказывается, нет.


 ![ КАРТИНКА ГДЕ Я СРАВНИВАЮ БРЕНД, ЛИНИЮ ПРОДУКТА И КЛАСС](/image/brand.png " КАРТИНКА ГДЕ Я СРАВНИВАЮ БРЕНД ЛИНИЮ ПРОДУКТА КЛАСС")

 Также я составил сравнительную таблицу для нахождения зависимостей между названием работы (job_title) и индустрией (job_industry_category). Зависимость не подтвердилась. Например, если job_title - Account Coordinator, то job_industry_category может быть Agriculture, Entertainment, Financial Services, Health, IT, Manufacturing и так далее... 


 ![КАРТИНКА ГДЕ СРАВНИВАЕТСЯ РАБОТА](/image/work.png " КАРТИНКА ГДЕ СРАВНИВАЕТСЯ РАБОТА")
 
 Помимо этих столбцов, в таблице customer есть еще другие: например, address, postcode, state и country. Оказалось, что адрес не задает однозначно штат и почтовый индекс (могут быть одинаковые адреса в разных неселенных пунктах внутри одного штата). Поэтому было решено адрес оставить в таблице customers и создать отдельную табличку (postcode, state, country) с ключом postcode_id. Дело в том, что в самой табличке штаты могут быть записаны по-разному, но обозначать одно и то же (VIC и Victoria). postcode_id будет однозначно задавать тройку (postcode, state, country) даже с учетом различной записи.

 
 ![КАРТИНКА, ГДЕ АДРЕСА В РАЗНЫХ ШТАТАХ И С РАЗНЫМИ КОДАМИ](/image/addr.png " КАРТИНКА, ГДЕ АДРЕСА В РАЗНЫХ ШТАТАХ И С РАЗНЫМИ КОДАМИ") 

В конечном итоге получилось привести таблички customer и transaction к 3NF. 
Структура базы данных со связями представлена на рисунке:

![КАРТИНКА БАЗЫ ДАННЫХ](/image/cust.png "КАРТИНКА БАЗЫ ДАННЫХ") 



 Обобщая все выше сказанное, таблица transaction находилась изначально в форме 3NF, таблица customer - в 2NF, но мы её потом привели к 3NF. Более того, так как у таблицы transaction ключ простой, то она автоматически удовлетворяет условиям нормальной формы Бойса-Кодда (BCNF)

Для того чтобы сделать из таблицы transaction 2NF, можно просто добавить транзитивную зависимость. Например, между product_line и list_price (искуственно сделать так, чтобы одинаковым значениям product_line соответствовали одинаковые list_price. Изначально это не так). Чтобы сделать 1NF - можно после приведения к 2NF убрать ключ transaction_id. Чтобы сделать 0NF - можно добавить дубли

Так как таблица customer изначально находилась в 2NF, мы можем из этого начального состояния убрать ключ для получения 1NF. Для превращения в 0NF можно, например, записывать данные в столбец owns_car в разных типах данных (то в bool, то в varchar, допустим)



Ниже предоставлен код для создания таблиц со связями один-к-одному, который я вставил в DBeaver. Параметр NOT NULL я подставлял тем столбцам, у которых действительно нету пустых ячеек в исходном файле (поиск пустых ячеек проводил через условное форматирование в Google Sheets):

```

CREATE TABLE "transaction" (
  "transaction_id" integer PRIMARY KEY,
  "product_id" integer NOT NULL,
  "customer_id" integer NOT NULL,
  "transaction_date" date NOT NULL,
  "online_order" bool,
  "order_status" varchar NOT NULL,
  "brand" varchar,
  "product_line" varchar,
  "product_class" varchar,
  "product_size" varchar,
  "list_price" float4 NOT NULL,
  "standard_cost" float4
);

CREATE TABLE "postcode" (
  "postcode_id" integer PRIMARY KEY,
  "postcode" integer NOT NULL,
  "state" varchar NOT NULL,
  "country" varchar NOT NULL
);

CREATE TABLE "customer" (
  "customer_id" integer PRIMARY KEY,
  "first_name" varchar NOT NULL,
  "last_name" varchar,
  "gender" varchar NOT NULL,
  "DOB" date,
  "job_title" varchar,
  "job_industry_category" varchar,
  "wealth_segment" varchar NOT NULL,
  "deceased_indicator" varchar NOT NULL,
  "owns_car" varchar NOT NULL,
  "address" varchar NOT NULL,
  "postcode_id" integer NOT NULL,
  "property_valuation" smallint NOT NULL,
);

ALTER TABLE transaction
ADD CONSTRAINT unique_customer_id UNIQUE (customer_id);



ALTER TABLE customer
ADD CONSTRAINT unique_postcode_id UNIQUE (postcode_id);

```

Процесс импорта:
![Процесс импорта](/image/down_process.png "Процесс импорта") 

Факт загрузки данных в таблицы:

![ТАБЛИЦА 1](/image/tab1.png "ТАБЛИЦА 1") 

![ТАБЛИЦА 2](/image/tab2.png "ТАБЛИЦА 2") 

![ТАБЛИЦА 3](/image/tab3.png "ТАБЛИЦА 3") 
